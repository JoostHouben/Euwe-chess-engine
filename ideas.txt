Evaluation:
 - King safety:
   - Pawn shield
   - Pawn storm
   - King tropism
   - Open rays (virtual mobility)
   - Enemy square control near the king
- Pawn structure:
   - Make passed pawn bonus square dependent (not just rank). That way we can increase the bonus
     for pawns near the edges (potential outside passed pawns).
   - Make isolated pawn penalty square dependent. May want to reduce the penalty for advanced pawns
     and pawns near the edges.
   - Make doubled pawn penalty square dependent? Not sure what positions we would penalize / reward.
   - Backward pawn penalty.
   - Group features?
   - Hashing of pawn structure? Or maybe pawns + kings?
 - Pieces:
   - Re-evaluate bishop pair bonus?
   - Decrease value of knight as pawns disappear
   - Increase value of rook as pawns disappear
 - Mobility / control
 - Pinned pieces
 - Relatively pinned pieces
 - Skewers / x-rays
 - Lazy evaluation
   - Might not work well with fail-soft search... use fail-hard?
 - End game evaluation:
   - Special heuristics for endgames:
     - Pawn endgames
     - ...
   - Endgame tablebases
 - Tuning: TD(lambda) learning or Texel tuning
 - Neural nets

Search:
 - Move ordering:
   - History heuristic
   - Counter move heuristic
   - Static exchange evaluation
   - Prioritize captures of last moved piece (over MVV/LVA)
- Algorithmic improvements:
   - MTD(f)?
   - Keep track of (expected) node type for informing pruning decisions
 - Pruning techniques:
   - Null move pruning
   - Multi-cut pruning
   - Enhanced forward pruning
   - Futility pruning
   - Delta pruning (quiescence search)
 - Reduction techniques:
   - Late move reduction
   - Razoring
 - Extensions:
   - Check extension
   - Mate threat extension
   - Passed pawn extension

Time control:
 - Implement real time control
 - Dynamically increase allotted time based on search progression

Speed ups:
 - General profiling & fixing bottlenecks
 - Use pseudo-legal move generation (when not in check)
 - Parallelism

(Potential) bug fixing:
 - Do move legality check for hash moves

Testing:
 - Add some mechanism to log important events during testing
 - Unit tests:
   - Evaluation testing:
     - A/B testing of specific features to ensure they are scored as expected
   - End-to-end testing:
     - For all of these we may need to use a fixed depth search instead of time control so that the
       tests are not dependent on the speed of the machine and optimization level.
     - 'Puzzles': find the right move in a given position
     - Play mate sequence: ensure that in self-play mate is reached within some given number of moves.
       - Number of moves should be based on theoretical mate sequence, but with some margin as needed.

Fun stuff:
 - Run engine on a chess website (lichess?)
 - Submit to CCRL
 - Share with interested friends
 - Chess variants?